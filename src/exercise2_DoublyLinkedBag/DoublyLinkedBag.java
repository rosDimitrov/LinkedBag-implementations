package exercise2_DoublyLinkedBag;/** * A class of bags whose entries are stored in a chain of single-linked nodes. * The bag is never full. */public class DoublyLinkedBag<T> implements BagI<T> {	private Node<T> firstNode; // reference to first node	private Node<T> lastNode;	private int size; // number of entries	public DoublyLinkedBag() {		lastNode = new Node<T>(null, null, null);		firstNode = new Node<T>(null, null, null);		firstNode.next = lastNode;		lastNode.previous = firstNode;		size = 0;	}	/**	 * Sees whether this bag is empty.	 * 	 * @return true if the bag is empty, or false if not	 */	@Override	public boolean isEmpty() {		return size == 0;	}	/**	 * Gets the number of entries currently in this bag.	 * 	 * @return the integer number of entries currently in the bag	 */	@Override	public int getCurrentSize() {		return size;	}	/**	 * Adds a new entry to this bag.	 * 	 * @param newEntry	 *            the object to be added as a new entry	 * @return true if the addition is successful, or false if not	 */	@Override	public boolean add(T newEntry) {		if (isFull()) {			return false;		}		Node<T> newNode = new Node<T>(newEntry, firstNode.next, firstNode);		firstNode.next.previous = newNode;		firstNode.next = newNode;		size++;		return true;	}	/**	 * Sees whether this bag is full.	 * 	 * @return false	 */	@Override	public boolean isFull() {		return false;	}	/**	 * Removes one unspecified entry from this bag, if possible.	 * 	 * @return either the removed entry, if the removal was successful, or null	 */	@Override	public T remove() {		// check if the bag is empty		if (isEmpty())			return null;		// generate random number, but should not be 0(0 is the first node)		int rand = (int) (Math.random()) * size;		if (rand == 0) {			rand++;		}		Node<T> temp = firstNode;		Node<T> result = null;		for (int i = 0; i < rand; i++) {			temp = temp.next;		}		result = temp;		temp.previous.next = temp.next;		temp.next.previous = temp.previous;		size--;		return result.getData();	}	/**	 * Removes one occurrence of a given entry from this bag.	 * 	 * @param anEntry	 *            the entry to be removed	 * @return true if the removal was successful, or false otherwise	 */	@Override	public boolean remove(T anEntry) {		if (isEmpty())			return false;		Node<T> temp = firstNode.next;		for (int i = 0; i < size; i++) {			if (temp.data.equals(anEntry)) {				Node<T> tempPrevious = temp.previous;				temp.previous = temp.next;				temp.next = tempPrevious;				size--;				return true;			} else {				temp = temp.next;			}		}		return false;	}	/** Removes all entries from this bag. */	@Override	public void clear() {		firstNode.next = lastNode;		lastNode.previous = firstNode;		size = 0;	}	/**	 * Counts the number of times a given entry appears in this bag.	 * 	 * @param anEntry	 *            the entry to be counted	 * @return the number of times anEntry appears in the bag	 */	@Override	public int getFrequencyOf(T anEntry) {		int count = 0;		Node<T> temp = firstNode.next;		for (int i = 1; i < size; i++) {			if (temp.data.equals(anEntry)) {				count++;			}			temp = temp.next;		}		return count;	}	/**	 * Tests whether this bag contains a given entry.	 * 	 * @param anEntry	 *            the entry to locate	 * @return true if the bag contains anEntry, or false otherwise	 */	@Override	public boolean contains(T anEntry) {		if (isEmpty())			return false;		Node<T> temp = firstNode.next;		for (int i = 1; i < size; i++) {			if (temp.data.equals(anEntry))				return true;			else {				temp = temp.next;			}		}		return false;	}	/**	 * Retrieves all entries that are in this bag.	 * 	 * @return a newly allocated array of all the entries in the bag	 */	@Override	public T[] toArray() {		// the cast is safe because the new array contains null entries		@SuppressWarnings("unchecked")		T[] result = (T[]) new Object[size]; // unchecked cast		int index = 0;		Node<T> currentNode = firstNode.next;		while (currentNode.data != null) {			result[index] = currentNode.data;			index++;			currentNode = currentNode.next;		}		return result;	}	private static class Node<T> {		private T data; // entry in bag		private Node<T> next; // link to next node		private Node<T> previous;		public Node(T data) {			this(data, null, null);		}		public Node(T data, Node<T> next, Node<T> previous) {			this.data = data;			this.next = next;			this.previous = previous;		}		public T getData() {			return data;		}		public Node<T> getNext() {			return next;		}	} // end Node<T> class} // end LinkedBag<T> class