package exercise1_SingleLinkedBag;/** * A class of bags whose entries are stored in a chain of single-linked nodes. * The bag is never full. */public class LinkedBag<T> implements BagI<T> {	private Node<T> firstNode; // reference to first node	private int size; // number of entries	public LinkedBag() {		firstNode = null;		size = 0;	}	/**	 * Sees whether this bag is empty.	 * 	 * @return true if the bag is empty, or false if not	 */	@Override	public boolean isEmpty() {		return size == 0;	}	/**	 * Gets the number of entries currently in this bag.	 * 	 * @return the integer number of entries currently in the bag	 */	@Override	public int getCurrentSize() {		return size;	}	/**	 * Adds a new entry to this bag.	 * 	 * @param newEntry	 *            the object to be added as a new entry	 * @return true if the addition is successful, or false if not	 */	@Override	public boolean add(T newEntry) {		// add to beginning of chain		Node<T> newNode = new Node<T>(newEntry);		newNode.next = firstNode;		firstNode = newNode;		size++;		return true;	}	/**	 * Sees whether this bag is full.	 * 	 * @return false	 */	@Override	public boolean isFull() {		return false;	}	/**	 * Removes one unspecified entry from this bag, if possible.	 * 	 * @return either the removed entry, if the removal was successful, or null	 */	@Override	public T remove() {		T result = null;		if (firstNode != null) {			result = firstNode.data;			firstNode = firstNode.next;			size--;		}		return result;	}	/**	 * Removes one occurrence of a given entry from this bag.	 * 	 * @param anEntry	 *            the entry to be removed	 * @return true if the removal was successful, or false otherwise	 */	@Override	public boolean remove(T anEntry) {				// VERSION 1 - my version		if (isEmpty()) {			return false;		}		Node<T> currentNode = firstNode;		// check and remove if the ENtrY is the first Node		if (currentNode.data.equals(anEntry)) {			firstNode = firstNode.next;			size--;			return true;		}		// check after the firstNode, because it's already checked.		for (int i = 0; i < size - 2; i++) {			if (currentNode.next.data.equals(anEntry)) {				currentNode.next = currentNode.next.next;			}			currentNode = currentNode.next;		}		this.size--;		return true;//		// VERSION 2 - FROM THE TEXtBOOK//		boolean result = false;//		Node nodeN = getReferenceTo(anEntry);//		//		if(nodeN != null){//			nodeN.data = firstNode.data; //save the data from the first node to the one you //										//are going to delete. After that delete the first node. //										//The first node is saved in the one that you deleted. //			remove();//			result = true;//		}//		return result;			}	private Node<T> getReferenceTo(T anEntry) {		boolean found = false;		Node<T> currentNode = firstNode;		while (!found && (currentNode != null)) {			if (anEntry.equals(currentNode.data)) {				found = true;			} else {				currentNode = currentNode.next;			}		}		return currentNode;	}	/** Removes all entries from this bag. */	@Override	public void clear() {		this.firstNode = null;		size = 0;	}	/**	 * Counts the number of times a given entry appears in this bag.	 * 	 * @param anEntry	 *            the entry to be counted	 * @return the number of times anEntry appears in the bag	 */	@Override	public int getFrequencyOf(T anEntry) {		int frequency = 0;		int counter = 0;		Node<T> currentNode = firstNode;		while ((currentNode != null) && (counter < size)) {			if (anEntry.equals(currentNode.data)) {				frequency++;			}			counter++;			currentNode = currentNode.next;		}		return frequency;	}	/**	 * Tests whether this bag contains a given entry.	 * 	 * @param anEntry	 *            the entry to locate	 * @return true if the bag contains anEntry, or false otherwise	 */	@Override	public boolean contains(T anEntry) {		boolean found = false;		Node<T> currentNode = firstNode;		while ((found != true) && (currentNode != null)) {			if (anEntry.equals(currentNode.data)) {				found = true;			} else {				currentNode = currentNode.next;			}		}		return found;	}	/**	 * Retrieves all entries that are in this bag.	 * 	 * @return a newly allocated array of all the entries in the bag	 */	@Override	public T[] toArray() {		// the cast is safe because the new array contains null entries		@SuppressWarnings("unchecked")		T[] result = (T[]) new Object[size]; // unchecked cast		int index = 0;		Node<T> currentNode = firstNode;		while (currentNode != null) {			result[index] = currentNode.data;			index++;			currentNode = currentNode.next;		}		return result;	}	private static class Node<T> {		private T data; // entry in bag		private Node<T> next; // link to next node		public Node(T data) {			this(data, null);		}		public Node(T data, Node<T> next) {			this.data = data;			this.next = next;		}		public T getData() {			return data;		}		public Node<T> getNext() {			return next;		}	} // end Node<T> class} // end LinkedBag<T> class